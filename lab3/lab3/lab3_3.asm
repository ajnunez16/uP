/*
lab 3, 3. INTERFACING WITH EXTERNAL SRAM
Name: Alexander Nunez
Class #: 11697
PI Name: Chris Crary
Description: This program employs ebi to connect to external sram.
*/

.include "ATxmega128A1Udef.inc"

;******************************INITIALIZATIONS***************************************
.set OUT_PORT = 0x19000		
.set OUT_PORT_END = 0x1903F
.set SRAM_PORT = 0x370000
.set SRAM_PORT_END = 0x377FFF	

; Start the program (skipping the early addresses)
.org 0x0000
	rjmp MAIN

.org 0x100
TABLE:
.db 0x4d, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x79, 0x6f, 0x75
.db 0x72, 0x20, 0x77, 0x61, 0x79, 0x20, 0x69, 0x6e, 0x20, 0x74
.db 0x68, 0x65, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x20, 0x74
.db 0x6f, 0x64, 0x61, 0x79, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x73
.db 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x74, 0x68, 0x69, 0x6e
.db 0x67, 0x20, 0x79, 0x6f, 0x75, 0x27, 0x76, 0x65, 0x20, 0x67
.db 0x6f, 0x74, 0x2e, 0x0a, 0x54, 0x61, 0x6b, 0x69, 0x6e, 0x67
.db 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x20, 0x66
.db 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x79, 0x6f
.db 0x75, 0x72, 0x20, 0x77, 0x6f, 0x72, 0x72, 0x69, 0x65, 0x73
.db 0x2c, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x77, 0x6f, 0x75
.db 0x6c, 0x64, 0x20, 0x68, 0x65, 0x6c, 0x70, 0x20, 0x61, 0x20
.db 0x6c, 0x6f, 0x74, 0x2e, 0x0a, 0x57, 0x6f, 0x75, 0x6c, 0x64
.db 0x6e, 0x27, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6c, 0x69
.db 0x6b, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x67, 0x65, 0x74, 0x20
.db 0x61, 0x77, 0x61, 0x79, 0x3f, 0x0a, 0x53, 0x6f, 0x6d, 0x65
.db 0x74, 0x69, 0x6d, 0x65, 0x73, 0x20, 0x79, 0x6f, 0x75, 0x20
.db 0x77, 0x61, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x67, 0x6f
.db 0x0a, 0x57, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65, 0x76, 0x65
.db 0x72, 0x79, 0x62, 0x6f, 0x64, 0x79, 0x20, 0x6b, 0x6e, 0x6f
.db 0x77, 0x73, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6e, 0x61
.db 0x6d, 0x65, 0x2c, 0x0a, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68
.db 0x65, 0x79, 0x27, 0x72, 0x65, 0x20, 0x61, 0x6c, 0x77, 0x61
.db 0x79, 0x73, 0x20, 0x67, 0x6c, 0x61, 0x64, 0x20, 0x79, 0x6f
.db 0x75, 0x20, 0x63, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x59, 0x6f
.db 0x75, 0x20, 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20, 0x62, 0x65
.db 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x79, 0x6f, 0x75
.db 0x20, 0x63, 0x61, 0x6e, 0x20, 0x73, 0x65, 0x65, 0x2c, 0x0a
.db 0x6f, 0x75, 0x72, 0x20, 0x74, 0x72, 0x6f, 0x75, 0x62, 0x6c
.db 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x6c, 0x6c
.db 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x0a
.db 0x59, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20
.db 0x62, 0x65, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65
.db 0x76, 0x65, 0x72, 0x79, 0x62, 0x6f, 0x64, 0x79, 0x20, 0x6b
.db 0x6e, 0x6f, 0x77, 0x73, 0x0a, 0x59, 0x6f, 0x75, 0x72, 0x20
.db 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x59, 0x6f, 0x75, 0x20
.db 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20, 0x67, 0x6f, 0x20, 0x77
.db 0x68, 0x65, 0x72, 0x65, 0x20, 0x70, 0x65, 0x6f, 0x70, 0x6c
.db 0x65, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x2c, 0x0a, 0x70, 0x65
.db 0x6f, 0x70, 0x6c, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61
.db 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d
.db 0x65, 0x2c, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x6e
.db 0x6e, 0x61, 0x20, 0x67, 0x6f, 0x20, 0x77, 0x68, 0x65, 0x72
.db 0x65, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x62, 0x6f, 0x64
.db 0x79, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x73, 0x0a, 0x79, 0x6f
.db 0x75, 0x72, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x20, 0x20

.ORG 0x0400	
; Write the rest of the program	(MAIN)
MAIN:
	; Initialize WE(L), RE(L), CS0(L), and CS1(L) by giving them default values (H) 
	; bits 0, 1, 3, and 4 respectively
	ldi r16, 0b11011		
	sts PORTH_OUTSET, r16
	; Initialize DIR for PORTH outputs CS0(L), CS1(L), ALE1(H), RE(L), and WE(L)
	ldi r16, 0b11111
	sts PORTH_DIRSET, r16
	; Initialize PORTK pins for outputs (A15-A0)
	ldi r16, 0xFF
	sts PORTK_DIRSET, r16
	; Initialize PORTJ pins for outputs (D7-D0), because the manual says so!
	ldi r16, 0xFF
	sts PORTJ_DIRSET, r16
	; Initialize the SRAM ALE1 3-port mode in EBI_CTRL
	ldi r16, 0x01
	sts EBI_CTRL, r16
	; Initialize low byte (A7:6) of BASEADDR for CS1, EBI_CS1_BASEADDR
	ldi r16, byte1(OUT_PORT)
	sts EBI_CS1_BASEADDR, r16
	; Initialize middle byte (A15:8) of BASEADDR for CS1, EBI_CS1_BASEADDR
	ldi r16, byte2(OUT_PORT)
	sts EBI_CS1_BASEADDR, r16
	; Initialize high byte (A23:A16) of BASEADDR for CS1, EBI_CS1_BASEADDR+1
	ldi r16, byte3(OUT_PORT)
	sts EBI_CS1_BASEADDR+1, r16
	; Initialize middle byte (A15:8) of BASEADDR for CS0, EBI_CS0_BASEADDR
	ldi r16, byte2(SRAM_PORT)
	sts EBI_CS0_BASEADDR, r16
	; Initialize high byte (A23:A16) of BASEADDR for CS0, EBI_CS0_BASEADDR+1
	ldi r16, byte3(SRAM_PORT)
	sts EBI_CS0_BASEADDR+1, r16
	; Init EBI_CS1_CTRLA for 64 bits size (0x1 9000 - 0x1 903F) and turn on SRAM mode
	ldi r16, 0x00			
	sts EBI_CS1_CTRLA, r16
	; Init EBI_CS0_CTRLA for 32K size (0x37 0000 - 0x37 7FFF) and turn on SRAM mode
	ldi r16, 0x07			
	sts EBI_CS0_CTRLA, r16
	; Point to the SRAM with X
	ldi r16, byte3(SRAM_PORT)
	sts CPU_RAMPX, r16
	ldi XH, high(SRAM_PORT)
	ldi XL, low(SRAM_PORT)
	; Point to the OUT_PORT with Y
	ldi r16, byte3(OUT_PORT)
	sts CPU_RAMPX, r16
	ldi YH, high(OUT_PORT)
	ldi YL, low(OUT_PORT)

	ldi ZL, low(Table << 1)		;load the low byte of the Table address into ZL register
	ldi ZH, high(Table << 1)	;load the high byte of the Table address into ZH register
WRITE:
	; read text file into register
	lpm r16, Z+
	; write from register into sram
	st X+, r16
	; loop until read all text file
	cpi r16, 0xFF
	brne WRITE

; Continuously read the sram and output to led
RESTART:
	; set pointer to start of sram
	ldi r16, byte3(SRAM_PORT)
	sts CPU_RAMPX, r16
	ldi XH, high(SRAM_PORT)
	ldi XL, low(SRAM_PORT)
TEST:
	; read the sram into r16
	ld r16, X+
	; store r16 to the output port
	st Y, r16
	; wait 50ms
	ldi r20, 5
	rcall DELAY_X_10MS
	; check if sram at last address
	cpi r16, 0xFF
	breq RESTART
	; continuously loop
	rjmp TEST


	.org 0x700	;put this here only to know the address of subroutine
;*********************SUBROUTINES**************************************
; Subroutine Name: DELAY_10MS
; delay 10 ms by counting to 3998
; Inputs: None
; Ouputs: None
; Affected: R16, R17, R18, R19

DELAY_10MS:
	; push to stack
	push r16
	push r17
	push r18
	push r19
	; r16 = 0
	clr r16
	; r17 = 0xFF
	ldi r17, 0xFF
	; r18 = 0
	clr r18
	; r19 = 0x10
	ldi r19, 0x10

UP:
	; check if r16 = r17
	cp r16, r17
	; branch to upper if they’re =
	breq UPPER
	; r16++
	inc r16
	; loop to UP
	rjmp UP


UPPER:
	; r16 = 0
	clr r16
	; r18++
	inc r18
	; check if r18 != r19
	cp r18, r19
	; branch to upper if they’re !=
	brne UP

BACK:
	; pop from stack
	pop r18
	pop r17
	pop r16
	; return
	ret

;*********************SUBROUTINES**************************************
; Subroutine Name: DELAY_X_10MS
; delay 10 ms by counting to 3998
; Inputs: R20
; Ouputs: None
; Affected: R21

DELAY_X_10MS:
	; push to stack
	push r21
	; r21 = 0
	clr r21

UP1:
	; check if r20 = r21
	cp r20, r21
	; branch to back1 if they're =
	breq BACK1
	; call subroutine to delay 10ms
	rcall DELAY_10MS
	; r21++
	inc r21
	; loop to up1
	rjmp UP1

BACK1:
	; pop from stack
	pop r21
	; return
	ret